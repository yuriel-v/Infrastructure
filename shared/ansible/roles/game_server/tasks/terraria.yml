---
- name: Probe old installs
  stat:
    path: "{{ gs_terraria['install_dir'] }}"
  register: gs_terraria_old

- name: Fail on existing install if not in overwrite mode
  fail:
    msg: "Existing Terraria install detected - either delete/move the folder at home/vagrant/terraria or set gs_overwrite to true to clean it up"
  when:
    - gs_terraria_old.stat.exists
    - not gs_overwrite

- name: Ensure install folder is empty
  block:
    - file:
        path: "{{ gs_terraria['install_dir'] }}"
        state: absent
    
    - file:
        path: "{{ gs_terraria['install_dir'] }}"
        state: directory

- name: Set up Terraria dedicated server
  block:
    # prerequisites
    - package:
        name: "{{ gs_terraria_prerequisite }}"
        state: present
      loop:
        - tmux
        - ufw
      loop_control:
        loop_var: gs_terraria_prerequisite

    # download and extract
    - unarchive:
        remote_src: yes
        src: "{{ gs_terraria['link'] }}"
        dest: /tmp
        validate_certs: no
    
    # move linux files
    - copy:
        remote_src: yes
        src: "/tmp/{{ gs_terraria_dir }}/Linux/"
        dest: "{{ gs_terraria['install_dir'] }}"

- name: Configure networking
  become: yes
  block:
    - name: UFW - SSH
      ufw:
        rule: allow
        port: ssh
        proto: tcp

    - name: UFW - Terraria port
      ufw:
        rule: allow
        port: "{{ gs_terraria['port'] }}"
        proto: tcp
      notify: UFW - Enable
    
    # BUG: Enabling UFW, be it here or through the shell module, hangs up the SSH session,
    # despite actually working and the rule allowing SSH.
    # I personally have no clue how to fix this, so what'll be done here will be that
    # enabling UFW should be run as an async handler at the very end of the playbook.
    # That way, it doesn't matter if the SSH session hangs up or not.

    # module iptables is stupid and doesn't work
    - name: iptables - Terraria port
      shell: "iptables -A INPUT -p tcp --dport {{ gs_terraria['port'] }} -j ACCEPT"

- name: Template configurations and launch script
  block:
    - name: Fetch IP
      shell: cat /etc/server-ip.txt
      register: gs_terraria_zt_ip
      until: gs_terraria_zt_ip is succeeded
      retries: 20
      delay: 3

    - set_fact:
        gs_server_ip: "{{ gs_terraria_zt_ip['stdout'] }}"

    - name: Template configs
      template:
        src: terraria-config.txt.j2
        dest: "{{ gs_terraria['install_dir'] }}/config.txt"
    
    - name: Create terraria.d folder
      file:
        path: '{{ gs_terraria["install_dir"] }}/terraria.d'
        state: directory
    
    - name: Template launch and exit scripts
      template:
        src: launch.sh.j2
        dest: '{{ gs_terraria["install_dir"] }}/terraria.d/launch.sh'
    
    - template:
        src: exit.sh.j2
        dest: '{{ gs_terraria["install_dir"] }}/terraria.d/exit.sh'

    - name: Set modes +x for applicable scripts
      file:
        path: '{{ gs_terraria["install_dir"] }}/TerrariaServer.bin.x86_64'
        mode: '+x'
        state: file
      become: yes

    - file:
        path: '{{ gs_terraria["install_dir"] }}/terraria.d/launch.sh'
        mode: '+x'
        state: file
      become: yes

    - file:
        path: '{{ gs_terraria["install_dir"] }}/terraria.d/exit.sh'
        mode: '+x'
        state: file
      become: yes

    - name: Template Terraria systemd service
      template:
        src: terraria.service.j2
        dest: /etc/systemd/system/terraria.service
      become: yes

    - name: Start Terraria systemd service
      systemd:
        daemon_reload: yes
        enabled: yes
        state: started
        name: terraria.service
      become: yes
